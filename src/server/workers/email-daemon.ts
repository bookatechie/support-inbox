/**
 * Email daemon - polls IMAP for new emails and creates tickets
 */

import Imap from 'imap-simple';
import type { ImapSimple, Message } from 'imap-simple';
import type { FastifyBaseLogger } from 'fastify';
import { parseEmail, isAutoGenerated } from '../lib/email-parser.js';
import {
  createTicketFromEmail,
  addMessageToTicket,
  findTicketByThreading,
  isEmailAlreadyProcessed,
} from '../lib/ticket.js';
import type { ImapConfig } from '../lib/types.js';
import { config } from '../lib/config.js';
import { userQueries } from '../lib/database-pg.js';

let isRunning = false;
let pollInterval: NodeJS.Timeout | null = null;
let logger: FastifyBaseLogger;
let consecutiveFailures = 0;
let currentBackoffMs = 0;
const MAX_BACKOFF_MS = 300000; // 5 minutes max backoff
const BASE_BACKOFF_MS = 30000; // 30 seconds base backoff

/**
 * Start email daemon
 */
export function startEmailDaemon(log: FastifyBaseLogger, imapConfig?: ImapConfig): void {
  logger = log;

  if (isRunning) {
    logger.info('Email daemon already running');
    return;
  }

  const emailConfig: ImapConfig = imapConfig || config.imap;

  isRunning = true;
  consecutiveFailures = 0;
  currentBackoffMs = 0;
  const pollMinutes = emailConfig.pollInterval / 60000;
  logger.info(`Starting email daemon (polling every ${pollMinutes} minute${pollMinutes !== 1 ? 's' : ''})`);

  // Initial check
  checkEmailsWithRetry(emailConfig);

  // Set up interval
  pollInterval = setInterval(() => {
    checkEmailsWithRetry(emailConfig);
  }, emailConfig.pollInterval);
}

/**
 * Stop email daemon
 */
export function stopEmailDaemon(): void {
  if (pollInterval) {
    clearInterval(pollInterval);
    pollInterval = null;
  }
  isRunning = false;
  consecutiveFailures = 0;
  currentBackoffMs = 0;
  logger.info('Email daemon stopped');
}

/**
 * Check emails with exponential backoff on failures
 */
async function checkEmailsWithRetry(config: ImapConfig): Promise<void> {
  // If we're in backoff period, skip this check
  if (currentBackoffMs > 0) {
    logger.debug(`Skipping email check (in backoff period: ${currentBackoffMs / 1000}s)`);
    currentBackoffMs = Math.max(0, currentBackoffMs - config.pollInterval);
    return;
  }

  try {
    await checkEmails(config);

    // Success - reset failure counter and backoff
    if (consecutiveFailures > 0) {
      logger.info('IMAP connection restored');
      consecutiveFailures = 0;
      currentBackoffMs = 0;
    }
  } catch (error) {
    consecutiveFailures++;

    // Calculate exponential backoff: 30s, 1m, 2m, 4m, 5m (max)
    const backoffMs = Math.min(
      BASE_BACKOFF_MS * Math.pow(2, consecutiveFailures - 1),
      MAX_BACKOFF_MS
    );
    currentBackoffMs = backoffMs;

    logger.error(
      error,
      `IMAP connection failed (${consecutiveFailures} consecutive failures). ` +
      `Retrying in ${backoffMs / 1000}s`
    );
  }
}

/**
 * Check IMAP inbox for new emails
 */
async function checkEmails(config: ImapConfig): Promise<void> {
  let connection: ImapSimple | null = null;

  try {
    // Connect to IMAP with timeout
    connection = await Imap.connect({
      imap: {
        user: config.user,
        password: config.password,
        host: config.host,
        port: config.port,
        tls: config.tls,
        authTimeout: 30000, // 30 second auth timeout
      },
    });

    // Add error handler on underlying IMAP connection to catch Parser errors
    // This fixes a known bug in the imap library where self._curReq can be undefined
    // and throws "Cannot read properties of undefined (reading 'type')"
    const imapConnection = (connection as any).imap;
    if (imapConnection) {
      imapConnection.on('error', (err: Error) => {
        logger.warn({ err: err.message }, 'IMAP connection error (handled)');
      });
    }

    // Open inbox
    await connection.openBox('INBOX');

    // Search for unseen emails
    const searchCriteria = ['UNSEEN'];
    const fetchOptions = {
      bodies: [''], // Fetch entire message
      markSeen: true,
    };

    const messages: Message[] = await connection.search(searchCriteria, fetchOptions);

    if (messages.length === 0) {
      logger.info('No new emails');
      return;
    }

    logger.info(`Found ${messages.length} new email(s)`);

    // Process each message
    for (const message of messages) {
      try {
        await processMessage(message);
      } catch (error) {
        logger.error(error, 'Error processing message');
      }
    }
  } catch (error) {
    // Log specific error types for better debugging
    if (error instanceof Error) {
      if (error.message.includes('authenticate') || error.message.includes('login')) {
        logger.error('IMAP authentication failed - check credentials');
      } else if (error.message.includes('ECONNREFUSED') || error.message.includes('ETIMEDOUT')) {
        logger.error('IMAP connection failed - check host/port and network');
      } else if (error.message.includes('ENOTFOUND')) {
        logger.error('IMAP host not found - check hostname');
      } else {
        logger.error(error, 'IMAP error');
      }
    } else {
      logger.error(error, 'Unknown IMAP error');
    }
    throw error;
  } finally {
    // Safely close connection - MUST destroy underlying imap to prevent memory leak
    // imap-simple's end() doesn't fully clean up event listeners
    if (connection) {
      try {
        const imapConn = (connection as any).imap;
        if (imapConn) {
          // Wait for connection to close gracefully, then destroy to clean up listeners
          // This prevents the "Cannot read properties of undefined (reading 'type')" crash
          // that occurs when destroy() is called while parser is still processing
          const closePromise = new Promise<void>((resolve) => {
            const timeout = setTimeout(() => {
              resolve(); // Force resolve after 2s if connection hangs
            }, 2000);
            imapConn.once('close', () => {
              clearTimeout(timeout);
              resolve();
            });
          });
          connection.end();
          await closePromise;
          imapConn.destroy();
        } else {
          connection.end();
        }
      } catch (closeError) {
        logger.debug(closeError, 'Error closing IMAP connection');
      }
    }
  }
}

/**
 * Find assignee by checking if any To/CC addresses match agent_email
 */
async function findAssigneeByEmail(toAddresses: string[]): Promise<number | undefined> {
  for (const email of toAddresses) {
    const user = await userQueries.getByAgentEmail(email.toLowerCase());
    if (user) {
      logger.info(`Auto-assigning to ${user.name} (${user.agent_email})`);
      return user.id;
    }
  }
  return undefined;
}

/**
 * Process a single IMAP message
 */
async function processMessage(message: Message): Promise<void> {
  // Get raw email content
  const all = message.parts.find(part => part.which === '');
  if (!all) {
    logger.error('Could not find email body');
    return;
  }

  const rawEmail = all.body;

  // Parse email
  const parsed = await parseEmail(rawEmail);

  logger.info(`Processing email: "${parsed.subject}" from ${parsed.from}`);

  // Check for duplicate emails (deduplication)
  if (await isEmailAlreadyProcessed(parsed.messageId)) {
    logger.info(`Skipping duplicate email (Message-ID: ${parsed.messageId?.substring(0, 20)}...)`);
    return;
  }

  // Skip auto-generated emails
  if (isAutoGenerated(parsed)) {
    logger.info('Skipping auto-generated email');
    return;
  }

  // Check if this is a reply to an existing ticket
  const existingTicket = await findTicketByThreading(parsed);

  if (existingTicket) {
    // Add to existing ticket
    logger.info(`Email is reply to ticket #${existingTicket.id}`);
    await addMessageToTicket(existingTicket.id, parsed);
  } else {
    // Log threading headers for debugging
    if (parsed.inReplyTo || parsed.references.length > 0) {
      logger.warn({
        inReplyTo: parsed.inReplyTo,
        references: parsed.references,
        from: parsed.from,
        subject: parsed.subject,
      }, 'Threading headers present but no existing ticket found');
    }

    // Check if email was sent to a specific agent's email address
    const assigneeId = await findAssigneeByEmail([...parsed.to, ...parsed.cc]);

    // Create new ticket with optional auto-assignment
    await createTicketFromEmail(parsed, logger, assigneeId);
  }
}

/**
 * Manual trigger for checking emails (used by API endpoint)
 */
export async function checkEmailsNow(): Promise<number> {
  try {
    await checkEmails(config.imap);
    logger.info('Manual email check completed successfully');
    return 1; // Success
  } catch (error) {
    logger.error(error, 'Manual email check failed');
    return 0; // Failure
  }
}
